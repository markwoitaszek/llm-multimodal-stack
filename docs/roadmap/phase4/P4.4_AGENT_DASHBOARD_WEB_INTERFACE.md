# Issue [P4.4] - Advanced Agent Dashboard & Web Interface

## üéØ **Objective**
Create a comprehensive web-based dashboard for managing autonomous agents, monitoring their performance, and providing an intuitive interface for agent creation, task orchestration, and collaboration.

## üìã **Priority & Dependencies**
- **Priority**: High
- **Dependencies**: [P4.2] Autonomous Agent Framework Core, [P4.3] Workflow Automation Engine
- **Timeline**: 3 weeks
- **Team Size**: 2-3 developers (1 frontend, 1-2 backend)

## üöÄ **Core Components**

### **1. React-Based Agent Dashboard**
Modern, responsive web interface for agent management.

```typescript
// services/agent-dashboard/src/components/AgentDashboard.tsx
import React, { useState, useEffect } from 'react';
import { AgentCard, AgentCreationWizard, PerformanceMetrics, TaskOrchestrator } from './components';

interface AgentDashboardProps {
  user: User;
}

export const AgentDashboard: React.FC<AgentDashboardProps> = ({ user }) => {
  const [agents, setAgents] = useState<Agent[]>([]);
  const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);
  const [dashboardView, setDashboardView] = useState<'overview' | 'agents' | 'tasks' | 'analytics'>('overview');

  useEffect(() => {
    loadAgents();
    loadPerformanceMetrics();
  }, []);

  const loadAgents = async () => {
    try {
      const response = await fetch('/api/v1/agents');
      const data = await response.json();
      setAgents(data.agents);
    } catch (error) {
      console.error('Failed to load agents:', error);
    }
  };

  const createAgent = async (agentConfig: CreateAgentRequest) => {
    try {
      const response = await fetch('/api/v1/agents', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(agentConfig)
      });
      
      if (response.ok) {
        await loadAgents();
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to create agent:', error);
      return false;
    }
  };

  const executeTask = async (agentId: string, task: string, context?: any) => {
    try {
      const response = await fetch(`/api/v1/agents/${agentId}/execute`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ task, context })
      });
      
      return await response.json();
    } catch (error) {
      console.error('Failed to execute task:', error);
      return null;
    }
  };

  return (
    <div className="agent-dashboard">
      <DashboardHeader 
        user={user}
        view={dashboardView}
        onViewChange={setDashboardView}
      />
      
      <div className="dashboard-content">
        {dashboardView === 'overview' && (
          <DashboardOverview 
            agents={agents}
            onAgentSelect={setSelectedAgent}
          />
        )}
        
        {dashboardView === 'agents' && (
          <AgentManagement 
            agents={agents}
            onCreateAgent={createAgent}
            onAgentSelect={setSelectedAgent}
            selectedAgent={selectedAgent}
          />
        )}
        
        {dashboardView === 'tasks' && (
          <TaskOrchestration 
            agents={agents}
            onExecuteTask={executeTask}
          />
        )}
        
        {dashboardView === 'analytics' && (
          <PerformanceAnalytics 
            agents={agents}
          />
        )}
      </div>
    </div>
  );
};

// Agent Creation Wizard Component
interface AgentCreationWizardProps {
  onAgentCreated: (agent: Agent) => void;
  onCancel: () => void;
}

export const AgentCreationWizard: React.FC<AgentCreationWizardProps> = ({ 
  onAgentCreated, 
  onCancel 
}) => {
  const [step, setStep] = useState(1);
  const [agentConfig, setAgentConfig] = useState<Partial<CreateAgentRequest>>({});
  const [templates, setTemplates] = useState<AgentTemplate[]>([]);

  useEffect(() => {
    loadTemplates();
  }, []);

  const loadTemplates = async () => {
    try {
      const response = await fetch('/api/v1/agent-templates');
      const data = await response.json();
      setTemplates(data.templates);
    } catch (error) {
      console.error('Failed to load templates:', error);
    }
  };

  const handleTemplateSelect = (template: AgentTemplate) => {
    setAgentConfig({
      name: `${template.name} - ${Date.now()}`,
      goal: template.goal,
      tools: template.tools,
      personality: template.personality,
      template: template.id
    });
  };

  const handleCreateAgent = async () => {
    try {
      const response = await fetch('/api/v1/agents', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(agentConfig)
      });
      
      if (response.ok) {
        const agent = await response.json();
        onAgentCreated(agent);
      }
    } catch (error) {
      console.error('Failed to create agent:', error);
    }
  };

  return (
    <div className="agent-creation-wizard">
      <div className="wizard-header">
        <h2>Create New Agent</h2>
        <button onClick={onCancel} className="close-btn">√ó</button>
      </div>
      
      <div className="wizard-steps">
        <div className={`step ${step >= 1 ? 'active' : ''}`}>
          <span>1. Template</span>
        </div>
        <div className={`step ${step >= 2 ? 'active' : ''}`}>
          <span>2. Configuration</span>
        </div>
        <div className={`step ${step >= 3 ? 'active' : ''}`}>
          <span>3. Review</span>
        </div>
      </div>
      
      <div className="wizard-content">
        {step === 1 && (
          <TemplateSelection 
            templates={templates}
            onTemplateSelect={handleTemplateSelect}
            onNext={() => setStep(2)}
          />
        )}
        
        {step === 2 && (
          <AgentConfiguration 
            config={agentConfig}
            onChange={setAgentConfig}
            onNext={() => setStep(3)}
            onBack={() => setStep(1)}
          />
        )}
        
        {step === 3 && (
          <AgentReview 
            config={agentConfig}
            onCreate={handleCreateAgent}
            onBack={() => setStep(2)}
          />
        )}
      </div>
    </div>
  );
};
```

### **2. Task Orchestration Interface**
Visual workflow designer for agent task management.

```typescript
// services/agent-dashboard/src/components/TaskOrchestrator.tsx
import React, { useState, useCallback } from 'react';
import { ReactFlow, Node, Edge, Controls, Background, useNodesState, useEdgesState } from 'reactflow';

interface TaskOrchestratorProps {
  agents: Agent[];
  onExecuteTask: (agentId: string, task: string, context?: any) => Promise<any>;
}

export const TaskOrchestrator: React.FC<TaskOrchestratorProps> = ({ 
  agents, 
  onExecuteTask 
}) => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [selectedNode, setSelectedNode] = useState<Node | null>(null);
  const [executionStatus, setExecutionStatus] = useState<Map<string, ExecutionStatus>>(new Map());

  const onConnect = useCallback((params: any) => {
    setEdges((eds) => addEdge(params, eds));
  }, [setEdges]);

  const addAgentNode = (agent: Agent) => {
    const newNode: Node = {
      id: `agent-${agent.id}`,
      type: 'agentNode',
      position: { x: Math.random() * 400, y: Math.random() * 400 },
      data: {
        label: agent.name,
        agent: agent,
        status: 'idle'
      }
    };
    
    setNodes((nds) => [...nds, newNode]);
  };

  const addTaskNode = (task: TaskDefinition) => {
    const newNode: Node = {
      id: `task-${Date.now()}`,
      type: 'taskNode',
      position: { x: Math.random() * 400, y: Math.random() * 400 },
      data: {
        label: task.name,
        task: task,
        status: 'pending'
      }
    };
    
    setNodes((nds) => [...nds, newNode]);
  };

  const executeWorkflow = async () => {
    const taskNodes = nodes.filter(node => node.type === 'taskNode');
    const agentNodes = nodes.filter(node => node.type === 'agentNode');
    
    for (const taskNode of taskNodes) {
      const task = taskNode.data.task;
      const connectedAgentEdges = edges.filter(
        edge => edge.target === taskNode.id && 
        agentNodes.some(agentNode => agentNode.id === edge.source)
      );
      
      if (connectedAgentEdges.length > 0) {
        const agentEdge = connectedAgentEdges[0];
        const agentNode = agentNodes.find(agent => agent.id === agentEdge.source);
        
        if (agentNode) {
          setExecutionStatus(prev => new Map(prev).set(taskNode.id, 'running'));
          
          try {
            const result = await onExecuteTask(
              agentNode.data.agent.id,
              task.description,
              task.context
            );
            
            setExecutionStatus(prev => new Map(prev).set(taskNode.id, 'completed'));
          } catch (error) {
            setExecutionStatus(prev => new Map(prev).set(taskNode.id, 'failed'));
          }
        }
      }
    }
  };

  const nodeTypes = {
    agentNode: AgentNodeComponent,
    taskNode: TaskNodeComponent,
    conditionNode: ConditionNodeComponent
  };

  return (
    <div className="task-orchestrator">
      <div className="orchestrator-header">
        <h2>Task Orchestration</h2>
        <div className="orchestrator-controls">
          <button onClick={executeWorkflow} className="execute-btn">
            Execute Workflow
          </button>
          <button onClick={() => setNodes([])} className="clear-btn">
            Clear Canvas
          </button>
        </div>
      </div>
      
      <div className="orchestrator-sidebar">
        <div className="agent-palette">
          <h3>Available Agents</h3>
          {agents.map(agent => (
            <div 
              key={agent.id}
              className="agent-palette-item"
              onClick={() => addAgentNode(agent)}
            >
              <span className="agent-name">{agent.name}</span>
              <span className="agent-goal">{agent.goal}</span>
            </div>
          ))}
        </div>
        
        <div className="task-templates">
          <h3>Task Templates</h3>
          <button 
            className="task-template"
            onClick={() => addTaskNode({
              name: 'Code Review',
              description: 'Review code changes',
              context: {}
            })}
          >
            Code Review
          </button>
          <button 
            className="task-template"
            onClick={() => addTaskNode({
              name: 'Generate Tests',
              description: 'Generate test cases',
              context: {}
            })}
          >
            Generate Tests
          </button>
          <button 
            className="task-template"
            onClick={() => addTaskNode({
              name: 'Update Documentation',
              description: 'Update project documentation',
              context: {}
            })}
          >
            Update Docs
          </button>
        </div>
      </div>
      
      <div className="orchestrator-canvas">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onNodeClick={(event, node) => setSelectedNode(node)}
          nodeTypes={nodeTypes}
          fitView
        >
          <Background />
          <Controls />
        </ReactFlow>
      </div>
      
      {selectedNode && (
        <NodePropertiesPanel 
          node={selectedNode}
          onUpdate={(updatedNode) => {
            setNodes(nds => nds.map(n => n.id === updatedNode.id ? updatedNode : n));
          }}
          onClose={() => setSelectedNode(null)}
        />
      )}
    </div>
  );
};
```

### **3. Performance Analytics Dashboard**
Real-time monitoring and analytics for agent performance.

```typescript
// services/agent-dashboard/src/components/PerformanceAnalytics.tsx
import React, { useState, useEffect } from 'react';
import { LineChart, BarChart, PieChart, ResponsiveContainer, Line, Bar, Pie, Cell } from 'recharts';

interface PerformanceAnalyticsProps {
  agents: Agent[];
}

export const PerformanceAnalytics: React.FC<PerformanceAnalyticsProps> = ({ agents }) => {
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    taskSuccessRate: 0,
    averageExecutionTime: 0,
    totalTasksExecuted: 0,
    agentUtilization: []
  });
  const [timeRange, setTimeRange] = useState<'24h' | '7d' | '30d'>('24h');

  useEffect(() => {
    loadPerformanceMetrics();
    const interval = setInterval(loadPerformanceMetrics, 30000); // Update every 30 seconds
    return () => clearInterval(interval);
  }, [timeRange]);

  const loadPerformanceMetrics = async () => {
    try {
      const response = await fetch(`/api/v1/analytics/performance?range=${timeRange}`);
      const data = await response.json();
      setMetrics(data);
    } catch (error) {
      console.error('Failed to load performance metrics:', error);
    }
  };

  const taskExecutionData = [
    { time: '00:00', completed: 12, failed: 2 },
    { time: '04:00', completed: 8, failed: 1 },
    { time: '08:00', completed: 25, failed: 3 },
    { time: '12:00', completed: 35, failed: 2 },
    { time: '16:00', completed: 28, failed: 4 },
    { time: '20:00', completed: 18, failed: 1 }
  ];

  const agentUtilizationData = agents.map(agent => ({
    name: agent.name,
    utilization: Math.random() * 100,
    tasksCompleted: Math.floor(Math.random() * 50) + 10,
    successRate: Math.random() * 20 + 80
  }));

  const taskTypeDistribution = [
    { name: 'Code Review', value: 35, color: '#8884d8' },
    { name: 'Testing', value: 25, color: '#82ca9d' },
    { name: 'Documentation', value: 20, color: '#ffc658' },
    { name: 'Debugging', value: 15, color: '#ff7c7c' },
    { name: 'Other', value: 5, color: '#8dd1e1' }
  ];

  return (
    <div className="performance-analytics">
      <div className="analytics-header">
        <h2>Performance Analytics</h2>
        <div className="time-range-selector">
          <button 
            className={timeRange === '24h' ? 'active' : ''}
            onClick={() => setTimeRange('24h')}
          >
            24 Hours
          </button>
          <button 
            className={timeRange === '7d' ? 'active' : ''}
            onClick={() => setTimeRange('7d')}
          >
            7 Days
          </button>
          <button 
            className={timeRange === '30d' ? 'active' : ''}
            onClick={() => setTimeRange('30d')}
          >
            30 Days
          </button>
        </div>
      </div>
      
      <div className="metrics-overview">
        <div className="metric-card">
          <h3>Task Success Rate</h3>
          <div className="metric-value">{metrics.taskSuccessRate.toFixed(1)}%</div>
          <div className="metric-trend positive">+2.3% from last period</div>
        </div>
        
        <div className="metric-card">
          <h3>Average Execution Time</h3>
          <div className="metric-value">{metrics.averageExecutionTime.toFixed(1)}s</div>
          <div className="metric-trend negative">+0.5s from last period</div>
        </div>
        
        <div className="metric-card">
          <h3>Total Tasks Executed</h3>
          <div className="metric-value">{metrics.totalTasksExecuted}</div>
          <div className="metric-trend positive">+15 from last period</div>
        </div>
        
        <div className="metric-card">
          <h3>Active Agents</h3>
          <div className="metric-value">{agents.length}</div>
          <div className="metric-trend neutral">No change</div>
        </div>
      </div>
      
      <div className="charts-grid">
        <div className="chart-container">
          <h3>Task Execution Over Time</h3>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={taskExecutionData}>
              <Line type="monotone" dataKey="completed" stroke="#82ca9d" strokeWidth={2} />
              <Line type="monotone" dataKey="failed" stroke="#ff7c7c" strokeWidth={2} />
            </LineChart>
          </ResponsiveContainer>
        </div>
        
        <div className="chart-container">
          <h3>Agent Utilization</h3>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart data={agentUtilizationData}>
              <Bar dataKey="utilization" fill="#8884d8" />
            </BarChart>
          </ResponsiveContainer>
        </div>
        
        <div className="chart-container">
          <h3>Task Type Distribution</h3>
          <ResponsiveContainer width="100%" height={300}>
            <PieChart>
              <Pie
                data={taskTypeDistribution}
                cx="50%"
                cy="50%"
                outerRadius={100}
                dataKey="value"
                label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
              >
                {taskTypeDistribution.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
            </PieChart>
          </ResponsiveContainer>
        </div>
      </div>
      
      <div className="agent-performance-table">
        <h3>Individual Agent Performance</h3>
        <table>
          <thead>
            <tr>
              <th>Agent</th>
              <th>Tasks Completed</th>
              <th>Success Rate</th>
              <th>Avg Execution Time</th>
              <th>Utilization</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            {agentUtilizationData.map(agent => (
              <tr key={agent.name}>
                <td>{agent.name}</td>
                <td>{agent.tasksCompleted}</td>
                <td>{agent.successRate.toFixed(1)}%</td>
                <td>{(Math.random() * 30 + 10).toFixed(1)}s</td>
                <td>{agent.utilization.toFixed(1)}%</td>
                <td>
                  <span className={`status ${agent.utilization > 80 ? 'busy' : 'available'}`}>
                    {agent.utilization > 80 ? 'Busy' : 'Available'}
                  </span>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};
```

## üõ†Ô∏è **Technical Implementation**

### **Backend API Extensions**
```python
# services/agent-dashboard/app/api.py
from fastapi import APIRouter, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

router = APIRouter()

# Serve static files
app.mount("/static", StaticFiles(directory="dist"), name="static")

@router.get("/", response_class=HTMLResponse)
async def serve_dashboard():
    """Serve the agent dashboard"""
    with open("dist/index.html", "r") as f:
        return HTMLResponse(content=f.read(), status_code=200)

# Analytics endpoints
@router.get("/api/v1/analytics/performance")
async def get_performance_analytics(range: str = "24h"):
    """Get performance analytics data"""
    try:
        db_manager = request.app.state.db_manager
        
        # Get metrics based on time range
        if range == "24h":
            start_time = datetime.utcnow() - timedelta(hours=24)
        elif range == "7d":
            start_time = datetime.utcnow() - timedelta(days=7)
        elif range == "30d":
            start_time = datetime.utcnow() - timedelta(days=30)
        else:
            raise ValueError("Invalid time range")
        
        # Calculate metrics
        metrics = await db_manager.get_performance_metrics(start_time)
        
        return {
            "taskSuccessRate": metrics["success_rate"],
            "averageExecutionTime": metrics["avg_execution_time"],
            "totalTasksExecuted": metrics["total_tasks"],
            "agentUtilization": metrics["agent_utilization"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/api/v1/analytics/task-execution")
async def get_task_execution_analytics(range: str = "24h"):
    """Get task execution analytics over time"""
    try:
        db_manager = request.app.state.db_manager
        
        # Get execution data over time
        execution_data = await db_manager.get_execution_timeline(range)
        
        return {
            "timeline": execution_data["timeline"],
            "completed": execution_data["completed"],
            "failed": execution_data["failed"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/api/v1/analytics/agent-performance")
async def get_agent_performance():
    """Get individual agent performance metrics"""
    try:
        db_manager = request.app.state.db_manager
        
        agent_performance = await db_manager.get_agent_performance_metrics()
        
        return {
            "agents": agent_performance
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# WebSocket for real-time updates
@router.websocket("/ws/dashboard")
async def websocket_dashboard(websocket: WebSocket):
    """WebSocket endpoint for real-time dashboard updates"""
    await websocket.accept()
    
    try:
        while True:
            # Send real-time metrics
            metrics = await get_live_metrics()
            await websocket.send_json({
                "type": "metrics_update",
                "data": metrics
            })
            
            await asyncio.sleep(5)  # Update every 5 seconds
            
    except WebSocketDisconnect:
        pass
    except Exception as e:
        await websocket.close(code=1011, reason=str(e))
```

### **Database Schema Extensions**
```sql
-- Performance analytics tables
CREATE TABLE performance_metrics (
    id UUID PRIMARY KEY,
    agent_id UUID REFERENCES agents(id),
    metric_type VARCHAR(100) NOT NULL,
    metric_value DECIMAL(10,3) NOT NULL,
    timestamp TIMESTAMP DEFAULT NOW()
);

CREATE TABLE execution_analytics (
    id UUID PRIMARY KEY,
    execution_id VARCHAR(255) REFERENCES workflow_executions(execution_id),
    agent_id UUID REFERENCES agents(id),
    task_type VARCHAR(100),
    execution_time DECIMAL(10,3),
    success BOOLEAN,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE dashboard_sessions (
    id UUID PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    session_data JSONB,
    last_activity TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Agent collaboration tables
CREATE TABLE agent_collaborations (
    id UUID PRIMARY KEY,
    collaboration_name VARCHAR(255) NOT NULL,
    description TEXT,
    participants JSONB NOT NULL,
    shared_context JSONB,
    created_by VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE collaboration_sessions (
    id UUID PRIMARY KEY,
    collaboration_id UUID REFERENCES agent_collaborations(id),
    session_name VARCHAR(255) NOT NULL,
    participants JSONB NOT NULL,
    shared_workspace JSONB,
    status VARCHAR(50) DEFAULT 'active',
    started_at TIMESTAMP DEFAULT NOW(),
    ended_at TIMESTAMP
);
```

### **Collaborative Workspace Features**
```typescript
// services/agent-dashboard/src/components/CollaborativeWorkspace.tsx
import React, { useState, useEffect } from 'react';

interface CollaborativeWorkspaceProps {
  user: User;
  agents: Agent[];
}

export const CollaborativeWorkspace: React.FC<CollaborativeWorkspaceProps> = ({ 
  user, 
  agents 
}) => {
  const [collaborations, setCollaborations] = useState<Collaboration[]>([]);
  const [activeCollaboration, setActiveCollaboration] = useState<Collaboration | null>(null);
  const [sharedContext, setSharedContext] = useState<SharedContext>({
    documents: [],
    tasks: [],
    discussions: []
  });

  const createCollaboration = async (name: string, description: string, participantAgents: Agent[]) => {
    try {
      const response = await fetch('/api/v1/collaborations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name,
          description,
          participants: participantAgents.map(agent => agent.id)
        })
      });
      
      if (response.ok) {
        const collaboration = await response.json();
        setCollaborations(prev => [...prev, collaboration]);
        return collaboration;
      }
    } catch (error) {
      console.error('Failed to create collaboration:', error);
    }
  };

  const startCollaborationSession = async (collaborationId: string) => {
    try {
      const response = await fetch(`/api/v1/collaborations/${collaborationId}/sessions`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          session_name: `Session ${new Date().toISOString()}`,
          participants: collaborations.find(c => c.id === collaborationId)?.participants || []
        })
      });
      
      if (response.ok) {
        const session = await response.json();
        setActiveCollaboration({
          ...collaborations.find(c => c.id === collaborationId)!,
          activeSession: session
        });
      }
    } catch (error) {
      console.error('Failed to start collaboration session:', error);
    }
  };

  return (
    <div className="collaborative-workspace">
      <div className="workspace-header">
        <h2>Collaborative Workspace</h2>
        <button 
          className="create-collaboration-btn"
          onClick={() => {/* Open creation modal */}}
        >
          Create Collaboration
        </button>
      </div>
      
      <div className="workspace-content">
        <div className="collaborations-sidebar">
          <h3>Active Collaborations</h3>
          {collaborations.map(collaboration => (
            <div 
              key={collaboration.id}
              className={`collaboration-item ${activeCollaboration?.id === collaboration.id ? 'active' : ''}`}
              onClick={() => setActiveCollaboration(collaboration)}
            >
              <div className="collaboration-name">{collaboration.name}</div>
              <div className="collaboration-description">{collaboration.description}</div>
              <div className="collaboration-participants">
                {collaboration.participants.length} participants
              </div>
            </div>
          ))}
        </div>
        
        <div className="workspace-main">
          {activeCollaboration ? (
            <div className="active-collaboration">
              <div className="collaboration-header">
                <h3>{activeCollaboration.name}</h3>
                <div className="collaboration-controls">
                  <button 
                    className="start-session-btn"
                    onClick={() => startCollaborationSession(activeCollaboration.id)}
                  >
                    Start Session
                  </button>
                  <button className="invite-btn">Invite Agents</button>
                </div>
              </div>
              
              <div className="collaboration-tabs">
                <button className="tab active">Shared Context</button>
                <button className="tab">Tasks</button>
                <button className="tab">Discussions</button>
                <button className="tab">Analytics</button>
              </div>
              
              <div className="collaboration-content">
                <SharedContextPanel 
                  context={sharedContext}
                  onContextUpdate={setSharedContext}
                  agents={activeCollaboration.participants}
                />
              </div>
            </div>
          ) : (
            <div className="no-collaboration">
              <h3>Select a collaboration to get started</h3>
              <p>Create a new collaboration or select an existing one to begin working with multiple agents.</p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
```

## üß™ **Testing Strategy**

### **Frontend Tests**
```typescript
// services/agent-dashboard/src/tests/AgentDashboard.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { AgentDashboard } from '../components/AgentDashboard';

describe('AgentDashboard', () => {
  const mockUser = { id: '1', name: 'Test User' };
  const mockAgents = [
    { id: '1', name: 'Test Agent', goal: 'Test goal', tools: ['analyze_code'] }
  ];

  beforeEach(() => {
    global.fetch = jest.fn();
  });

  test('renders dashboard with agents', async () => {
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => ({ agents: mockAgents })
    });

    render(<AgentDashboard user={mockUser} />);

    await waitFor(() => {
      expect(screen.getByText('Test Agent')).toBeInTheDocument();
    });
  });

  test('creates new agent successfully', async () => {
    const mockCreateResponse = {
      id: '2',
      name: 'New Agent',
      goal: 'New goal',
      tools: ['search_codebase']
    };

    (global.fetch as jest.Mock)
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({ agents: mockAgents })
      })
      .mockResolvedValueOnce({
        ok: true,
        json: async () => mockCreateResponse
      });

    render(<AgentDashboard user={mockUser} />);

    // Open agent creation wizard
    fireEvent.click(screen.getByText('Create Agent'));

    // Fill out form
    fireEvent.change(screen.getByLabelText('Agent Name'), {
      target: { value: 'New Agent' }
    });
    fireEvent.change(screen.getByLabelText('Goal'), {
      target: { value: 'New goal' }
    });

    // Submit form
    fireEvent.click(screen.getByText('Create Agent'));

    await waitFor(() => {
      expect(screen.getByText('New Agent')).toBeInTheDocument();
    });
  });
});
```

### **Backend Tests**
```python
# services/agent-dashboard/tests/test_api.py
import pytest
from fastapi.testclient import TestClient
from app.main import app

@pytest.fixture
def client():
    return TestClient(app)

def test_get_performance_analytics(client):
    """Test performance analytics endpoint"""
    response = client.get("/api/v1/analytics/performance?range=24h")
    
    assert response.status_code == 200
    data = response.json()
    assert "taskSuccessRate" in data
    assert "averageExecutionTime" in data
    assert "totalTasksExecuted" in data
    assert "agentUtilization" in data

def test_create_collaboration(client):
    """Test collaboration creation"""
    response = client.post("/api/v1/collaborations", json={
        "name": "Test Collaboration",
        "description": "Test description",
        "participants": ["agent1", "agent2"]
    })
    
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "Test Collaboration"
    assert "id" in data
```

## üìä **Success Metrics**

### **Technical Metrics**
- **Dashboard Load Time**: <3 seconds for initial load
- **Real-time Updates**: <1 second latency for live metrics
- **API Response Time**: <200ms for dashboard operations
- **User Interface Responsiveness**: <100ms for user interactions
- **Browser Compatibility**: Support for Chrome, Firefox, Safari, Edge

### **User Experience Metrics**
- **Setup Time**: <10 minutes from installation to first dashboard view
- **Feature Adoption**: 85%+ of users actively using dashboard features
- **User Satisfaction**: 4.5/5 rating for dashboard usability
- **Task Completion Rate**: 90%+ successful task orchestration

### **Integration Quality Metrics**
- **Agent Integration**: 100% compatibility with agent framework
- **Workflow Integration**: 100% compatibility with workflow engine
- **Real-time Performance**: 99.9% uptime for dashboard services
- **Data Accuracy**: 95%+ accuracy for performance metrics

## üöÄ **Deployment & Configuration**

### **Environment Variables**
```bash
# Agent Dashboard
AGENT_DASHBOARD_PORT=8006
REACT_APP_API_BASE_URL=http://localhost:8006
REACT_APP_WS_URL=ws://localhost:8006/ws

# Analytics
ANALYTICS_REFRESH_INTERVAL=30
METRICS_CACHE_SIZE=1000
METRICS_CACHE_TTL=300

# Collaboration
COLLABORATION_SESSION_TIMEOUT=3600
MAX_COLLABORATION_PARTICIPANTS=10
SHARED_CONTEXT_SIZE_LIMIT=10485760

# Database
POSTGRES_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
```

### **Docker Compose Integration**
```yaml
# Add new agent-dashboard service
services:
  agent-dashboard:
    build: ./services/agent-dashboard
    ports:
      - "8006:8006"
    environment:
      - AGENT_DASHBOARD_PORT=8006
      - POSTGRES_URL=postgresql://postgres:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      - AI_AGENTS_URL=http://ai-agents:8003
      - WORKFLOW_ENGINE_URL=http://workflow-engine:8007
    depends_on:
      - postgres
      - ai-agents
      - workflow-engine
    volumes:
      - ./services/agent-dashboard:/app
    networks:
      - multimodal-net
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8006/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## üìö **Documentation Requirements**

### **User Documentation**
- [ ] **Dashboard User Guide**: Complete guide to using the agent dashboard
- [ ] **Agent Management**: Creating, configuring, and managing agents
- [ ] **Task Orchestration**: Building and executing agent workflows
- [ ] **Collaboration Features**: Working with multiple agents collaboratively

### **Developer Documentation**
- [ ] **Dashboard API Reference**: Complete API documentation
- [ ] **Component Library**: React component documentation
- [ ] **Integration Guide**: Integrating with agent and workflow services
- [ ] **Customization Guide**: Customizing dashboard features

### **Architecture Documentation**
- [ ] **Dashboard Architecture**: Detailed component diagrams
- [ ] **Real-time Communication**: WebSocket and live update patterns
- [ ] **Performance Optimization**: Frontend and backend optimization
- [ ] **Security Model**: Authentication and authorization

## ‚úÖ **Acceptance Criteria**

### **Functional Requirements**
- [ ] React-based dashboard with responsive design
- [ ] Agent creation wizard with template support
- [ ] Visual task orchestration interface
- [ ] Real-time performance analytics and monitoring
- [ ] Collaborative workspace for multi-agent projects
- [ ] WebSocket-based real-time updates

### **Performance Requirements**
- [ ] Dashboard loads within 3 seconds
- [ ] Real-time updates with <1 second latency
- [ ] Support 50+ concurrent dashboard users
- [ ] API responses within 200ms
- [ ] 99.9% service uptime

### **Integration Requirements**
- [ ] Full integration with agent framework (P4.2)
- [ ] Full integration with workflow engine (P4.3)
- [ ] Database integration for analytics and collaboration
- [ ] Health checks and monitoring integration
- [ ] Docker containerization with proper networking

---

**Estimated Effort**: 3 weeks  
**Risk Level**: Medium (complex frontend, real-time features)  
**Business Impact**: High (provides intuitive interface for agent management)
