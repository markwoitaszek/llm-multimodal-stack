# Issue [P4.5] - Universal Protocol Integration (LSP/MCP)

## 🎯 **Objective**
Implement universal protocol support (LSP and MCP) to enable seamless integration with all major IDEs, providing standardized communication protocols for multimodal AI assistance.

## 📋 **Priority & Dependencies**
- **Priority**: High
- **Dependencies**: [P4.1] Enhanced IDE Integration Foundation
- **Timeline**: 2 weeks
- **Team Size**: 2 developers

## 🚀 **Core Components**

### **1. Language Server Protocol (LSP) Implementation**
Universal IDE support through standardized LSP server.

```python
# services/protocol-bridge/app/lsp_server.py
import json
import asyncio
import logging
from typing import Dict, List, Any, Optional, Union
from pygls.server import LanguageServer
from pygls.protocol import default_converter
from pygls.workspace import Document
from pygls.types import (
    CompletionItem, CompletionList, CompletionOptions,
    Diagnostic, DiagnosticSeverity, Position, Range,
    Hover, MarkupContent, MarkupKind,
    Definition, Location, ReferenceContext,
    TextDocumentSyncKind, TextDocumentSyncOptions
)

logger = logging.getLogger(__name__)

class MultimodalLSPServer(LanguageServer):
    """Language Server Protocol implementation for multimodal AI assistance"""
    
    def __init__(self, multimodal_client, retrieval_client, context_engine):
        super().__init__("multimodal-lsp", "1.0.0")
        self.multimodal_client = multimodal_client
        self.retrieval_client = retrieval_client
        self.context_engine = context_engine
        self.document_cache = {}
        self.context_cache = {}
        
        # Register capabilities
        self._register_capabilities()
        
        # Register handlers
        self._register_handlers()
    
    def _register_capabilities(self):
        """Register LSP server capabilities"""
        
        self.capabilities = {
            "textDocumentSync": TextDocumentSyncOptions(
                open_close=True,
                change=TextDocumentSyncKind.Full,
                save=True
            ),
            "completionProvider": CompletionOptions(
                resolve_provider=True,
                trigger_characters=[".", " ", "\n", "(", "["]
            ),
            "hoverProvider": True,
            "definitionProvider": True,
            "referencesProvider": True,
            "documentHighlightProvider": True,
            "documentSymbolProvider": True,
            "workspaceSymbolProvider": True,
            "codeActionProvider": True,
            "diagnosticProvider": {
                "identifier": "multimodal-diagnostics",
                "interFileDependencies": True,
                "workspaceDiagnostics": True
            },
            "renameProvider": True,
            "foldingRangeProvider": True,
            "selectionRangeProvider": True,
            "multimodalAnalysis": {  # Custom capability
                "supportedAnalysisTypes": [
                    "code_quality",
                    "security_analysis", 
                    "performance_analysis",
                    "architecture_review"
                ]
            }
        }
    
    def _register_handlers(self):
        """Register LSP request handlers"""
        
        @self.feature("textDocument/completion")
        async def on_completion(ls: "MultimodalLSPServer", params):
            """Provide intelligent code completions with multimodal context"""
            return await self._provide_completion(params)
        
        @self.feature("textDocument/hover")
        async def on_hover(ls: "MultimodalLSPServer", params):
            """Provide hover information with multimodal context"""
            return await self._provide_hover(params)
        
        @self.feature("textDocument/definition")
        async def on_definition(ls: "MultimodalLSPServer", params):
            """Provide definition information"""
            return await self._provide_definition(params)
        
        @self.feature("textDocument/references")
        async def on_references(ls: "MultimodalLSPServer", params):
            """Provide reference information"""
            return await self._provide_references(params)
        
        @self.feature("textDocument/diagnostic")
        async def on_diagnostic(ls: "MultimodalLSPServer", params):
            """Provide diagnostic information"""
            return await self._provide_diagnostics(params)
        
        @self.feature("textDocument/didOpen")
        async def on_did_open(ls: "MultimodalLSPServer", params):
            """Handle document open"""
            await self._handle_document_open(params)
        
        @self.feature("textDocument/didChange")
        async def on_did_change(ls: "MultimodalLSPServer", params):
            """Handle document change"""
            await self._handle_document_change(params)
        
        @self.feature("textDocument/didSave")
        async def on_did_save(ls: "MultimodalLSPServer", params):
            """Handle document save"""
            await self._handle_document_save(params)
    
    async def _provide_completion(self, params) -> CompletionList:
        """Provide intelligent code completions"""
        try:
            doc_uri = params.textDocument.uri
            position = params.position
            
            # Get document content
            document = self.workspace.get_document(doc_uri)
            content = document.source
            
            # Generate multimodal context
            context = await self.context_engine.generate_context(
                file_path=doc_uri,
                cursor_position=position.character + position.line * 1000,  # Approximate
                include_related=True,
                include_docs=True,
                include_diagrams=True
            )
            
            # Generate completions using multimodal context
            completions = await self._generate_completions(
                content, position, context
            )
            
            return CompletionList(
                is_incomplete=False,
                items=completions
            )
            
        except Exception as e:
            logger.error(f"Error providing completions: {e}")
            return CompletionList(is_incomplete=False, items=[])
    
    async def _generate_completions(self, 
                                   content: str, 
                                   position: Position, 
                                   context: Dict) -> List[CompletionItem]:
        """Generate completions using multimodal context"""
        
        # Extract current line and context
        lines = content.split('\n')
        current_line = lines[position.line] if position.line < len(lines) else ""
        before_cursor = current_line[:position.character]
        
        # Create completion prompt with context
        completion_prompt = f"""
        Based on the following code context and multimodal information, provide intelligent code completions for the cursor position:
        
        Current line: {current_line}
        Before cursor: {before_cursor}
        
        File context:
        {context.get('file_context', {}).get('content', '')[:1000]}
        
        Related code:
        {context.get('semantic_context', {}).get('similar_code', '')[:1000]}
        
        Documentation:
        {context.get('documentation', {}).get('relevant_docs', '')[:1000]}
        
        Provide 5-10 relevant code completions that would be helpful at this position.
        """
        
        # Use multimodal client to generate completions
        response = await self.multimodal_client.llm_client.generate_text(
            prompt=completion_prompt,
            max_tokens=500,
            temperature=0.3
        )
        
        # Parse response into completion items
        completions = self._parse_completion_response(response, before_cursor)
        
        return completions
    
    async def _provide_hover(self, params) -> Optional[Hover]:
        """Provide hover information with multimodal context"""
        try:
            doc_uri = params.textDocument.uri
            position = params.position
            
            document = self.workspace.get_document(doc_uri)
            content = document.source
            
            # Extract symbol at position
            symbol = self._extract_symbol_at_position(content, position)
            
            if not symbol:
                return None
            
            # Get multimodal context for symbol
            context = await self.context_engine.generate_context(
                file_path=doc_uri,
                cursor_position=position.character + position.line * 1000,
                include_related=True,
                include_docs=True
            )
            
            # Generate hover information
            hover_info = await self._generate_hover_info(symbol, context)
            
            return Hover(
                contents=MarkupContent(
                    kind=MarkupKind.Markdown,
                    value=hover_info
                ),
                range=Range(
                    start=position,
                    end=position
                )
            )
            
        except Exception as e:
            logger.error(f"Error providing hover: {e}")
            return None
    
    async def _generate_hover_info(self, symbol: str, context: Dict) -> str:
        """Generate hover information using multimodal context"""
        
        # Search for symbol information in context
        symbol_info = self._find_symbol_in_context(symbol, context)
        
        if symbol_info:
            return f"""
            **{symbol}**
            
            {symbol_info.get('description', 'No description available')}
            
            **Type**: {symbol_info.get('type', 'Unknown')}
            **Location**: {symbol_info.get('location', 'Unknown')}
            
            {symbol_info.get('documentation', '')}
            """
        
        # Fallback to general information
        return f"""
        **{symbol}**
        
        No specific information found. This appears to be a code symbol.
        """
    
    async def _provide_diagnostics(self, params) -> List[Diagnostic]:
        """Provide diagnostic information using multimodal analysis"""
        try:
            doc_uri = params.textDocument.uri
            document = self.workspace.get_document(doc_uri)
            content = document.source
            
            # Perform multimodal analysis
            analysis = await self.multimodal_client.process_text(
                text=content,
                document_name=doc_uri,
                metadata={
                    "type": "lsp_diagnostics",
                    "analysis_type": "comprehensive"
                }
            )
            
            # Generate diagnostics from analysis
            diagnostics = await self._generate_diagnostics_from_analysis(
                content, analysis
            )
            
            return diagnostics
            
        except Exception as e:
            logger.error(f"Error providing diagnostics: {e}")
            return []
    
    async def _generate_diagnostics_from_analysis(self, 
                                                 content: str, 
                                                 analysis: Dict) -> List[Diagnostic]:
        """Generate diagnostics from multimodal analysis"""
        
        diagnostics = []
        
        # Create analysis prompt
        analysis_prompt = f"""
        Analyze the following code and identify potential issues:
        
        {content}
        
        Look for:
        - Syntax errors
        - Logic errors
        - Security vulnerabilities
        - Performance issues
        - Code quality problems
        - Best practice violations
        
        Provide specific line numbers and descriptions for each issue.
        """
        
        # Get analysis from LLM
        analysis_result = await self.multimodal_client.llm_client.generate_text(
            prompt=analysis_prompt,
            max_tokens=1000
        )
        
        # Parse analysis into diagnostics
        diagnostics = self._parse_analysis_to_diagnostics(analysis_result, content)
        
        return diagnostics

# LSP Server startup
async def create_lsp_server():
    """Create and configure LSP server"""
    
    # Initialize clients
    multimodal_client = MultimodalClient("http://multimodal-worker:8001")
    retrieval_client = RetrievalClient("http://retrieval-proxy:8002")
    context_engine = CodeContextEngine(multimodal_client, retrieval_client, None)
    
    # Create LSP server
    server = MultimodalLSPServer(multimodal_client, retrieval_client, context_engine)
    
    return server

if __name__ == "__main__":
    # Start LSP server
    server = asyncio.run(create_lsp_server())
    server.start_io()
```

### **2. Microsoft Copilot Protocol (MCP) Implementation**
Integration with Microsoft Copilot ecosystem.

```python
# services/protocol-bridge/app/mcp_server.py
import json
import asyncio
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class MCPMessageType(Enum):
    INITIALIZE = "initialize"
    LIST_TOOLS = "tools/list"
    CALL_TOOL = "tools/call"
    LIST_RESOURCES = "resources/list"
    READ_RESOURCE = "resources/read"
    LIST_PROMPTS = "prompts/list"
    GET_PROMPT = "prompts/get"

@dataclass
class MCPTool:
    name: str
    description: str
    input_schema: Dict[str, Any]

@dataclass
class MCPResource:
    uri: str
    name: str
    description: str
    mime_type: str

@dataclass
class MCPPrompt:
    name: str
    description: str
    arguments: List[Dict[str, Any]]

class MCPServer:
    """Microsoft Copilot Protocol server implementation"""
    
    def __init__(self, multimodal_client, retrieval_client):
        self.multimodal_client = multimodal_client
        self.retrieval_client = retrieval_client
        self.tools = {}
        self.resources = {}
        self.prompts = {}
        
        self._register_multimodal_tools()
        self._register_resources()
        self._register_prompts()
    
    def _register_multimodal_tools(self):
        """Register multimodal tools for MCP"""
        
        self.tools = {
            "analyze_codebase": MCPTool(
                name="analyze_codebase",
                description="Analyze codebase with multimodal context including code quality, security, and architecture",
                input_schema={
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Analysis query or specific area to analyze"
                        },
                        "include_diagrams": {
                            "type": "boolean",
                            "description": "Include architecture diagrams in analysis",
                            "default": True
                        },
                        "analysis_depth": {
                            "type": "string",
                            "enum": ["quick", "standard", "comprehensive"],
                            "description": "Depth of analysis to perform",
                            "default": "standard"
                        }
                    },
                    "required": ["query"]
                }
            ),
            
            "search_code": MCPTool(
                name="search_code",
                description="Search codebase with semantic understanding and multimodal context",
                input_schema={
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "Search query"
                        },
                        "file_types": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "File types to search in",
                            "default": ["py", "js", "ts", "go", "java"]
                        },
                        "include_docs": {
                            "type": "boolean",
                            "description": "Include documentation in search",
                            "default": True
                        },
                        "limit": {
                            "type": "integer",
                            "description": "Maximum number of results",
                            "default": 10
                        }
                    },
                    "required": ["query"]
                }
            ),
            
            "generate_architecture_diagram": MCPTool(
                name="generate_architecture_diagram",
                description="Generate architecture diagram from codebase analysis",
                input_schema={
                    "type": "object",
                    "properties": {
                        "component_focus": {
                            "type": "string",
                            "description": "Focus area for diagram (e.g., 'services', 'data_flow', 'all')",
                            "default": "all"
                        },
                        "format": {
                            "type": "string",
                            "enum": ["mermaid", "plantuml", "dot"],
                            "description": "Diagram format",
                            "default": "mermaid"
                        },
                        "include_dependencies": {
                            "type": "boolean",
                            "description": "Include external dependencies",
                            "default": True
                        }
                    }
                }
            ),
            
            "analyze_image": MCPTool(
                name="analyze_image",
                description="Analyze image content and generate descriptions or extract information",
                input_schema={
                    "type": "object",
                    "properties": {
                        "image_url": {
                            "type": "string",
                            "description": "URL or path to the image"
                        },
                        "analysis_type": {
                            "type": "string",
                            "enum": ["caption", "objects", "text_extraction", "comprehensive"],
                            "description": "Type of analysis to perform",
                            "default": "comprehensive"
                        }
                    },
                    "required": ["image_url"]
                }
            ),
            
            "transcribe_video": MCPTool(
                name="transcribe_video",
                description="Extract text transcription from video content",
                input_schema={
                    "type": "object",
                    "properties": {
                        "video_url": {
                            "type": "string",
                            "description": "URL or path to the video"
                        },
                        "include_timestamps": {
                            "type": "boolean",
                            "description": "Include timestamps in transcription",
                            "default": True
                        },
                        "language": {
                            "type": "string",
                            "description": "Expected language of the audio",
                            "default": "auto"
                        }
                    },
                    "required": ["video_url"]
                }
            ),
            
            "generate_documentation": MCPTool(
                name="generate_documentation",
                description="Generate comprehensive documentation from code analysis",
                input_schema={
                    "type": "object",
                    "properties": {
                        "target_path": {
                            "type": "string",
                            "description": "Path to code file or directory to document"
                        },
                        "doc_type": {
                            "type": "string",
                            "enum": ["api_docs", "readme", "architecture", "user_guide"],
                            "description": "Type of documentation to generate",
                            "default": "api_docs"
                        },
                        "include_examples": {
                            "type": "boolean",
                            "description": "Include code examples in documentation",
                            "default": True
                        },
                        "format": {
                            "type": "string",
                            "enum": ["markdown", "html", "rst"],
                            "description": "Output format",
                            "default": "markdown"
                        }
                    },
                    "required": ["target_path"]
                }
            )
        }
    
    def _register_resources(self):
        """Register resources available through MCP"""
        
        self.resources = {
            "codebase_overview": MCPResource(
                uri="multimodal://codebase/overview",
                name="Codebase Overview",
                description="High-level overview of the entire codebase structure and architecture",
                mime_type="application/json"
            ),
            
            "api_documentation": MCPResource(
                uri="multimodal://docs/api",
                name="API Documentation",
                description="Comprehensive API documentation generated from code analysis",
                mime_type="text/markdown"
            ),
            
            "architecture_diagram": MCPResource(
                uri="multimodal://diagrams/architecture",
                name="Architecture Diagram",
                description="Current system architecture diagram",
                mime_type="text/plain"
            ),
            
            "performance_metrics": MCPResource(
                uri="multimodal://metrics/performance",
                name="Performance Metrics",
                description="Current system performance metrics and analytics",
                mime_type="application/json"
            )
        }
    
    def _register_prompts(self):
        """Register prompt templates for MCP"""
        
        self.prompts = {
            "code_review": MCPPrompt(
                name="code_review",
                description="Generate comprehensive code review with security and performance analysis",
                arguments=[
                    {
                        "name": "file_path",
                        "description": "Path to the code file to review",
                        "required": True
                    },
                    {
                        "name": "focus_areas",
                        "description": "Specific areas to focus on (security, performance, style, etc.)",
                        "required": False
                    }
                ]
            ),
            
            "explain_code": MCPPrompt(
                name="explain_code",
                description="Explain complex code sections with context and examples",
                arguments=[
                    {
                        "name": "code_section",
                        "description": "Code section to explain",
                        "required": True
                    },
                    {
                        "name": "explanation_level",
                        "description": "Level of explanation (beginner, intermediate, advanced)",
                        "required": False
                    }
                ]
            ),
            
            "generate_tests": MCPPrompt(
                name="generate_tests",
                description="Generate comprehensive test cases for code",
                arguments=[
                    {
                        "name": "target_code",
                        "description": "Code to generate tests for",
                        "required": True
                    },
                    {
                        "name": "test_framework",
                        "description": "Testing framework to use",
                        "required": False
                    },
                    {
                        "name": "test_types",
                        "description": "Types of tests to generate (unit, integration, e2e)",
                        "required": False
                    }
                ]
            )
        }
    
    async def handle_request(self, request: Dict) -> Dict:
        """Handle MCP request"""
        try:
            method = request.get("method")
            params = request.get("params", {})
            request_id = request.get("id")
            
            if method == MCPMessageType.INITIALIZE.value:
                return self._handle_initialize(request_id, params)
            elif method == MCPMessageType.LIST_TOOLS.value:
                return self._handle_list_tools(request_id)
            elif method == MCPMessageType.CALL_TOOL.value:
                return await self._handle_call_tool(request_id, params)
            elif method == MCPMessageType.LIST_RESOURCES.value:
                return self._handle_list_resources(request_id)
            elif method == MCPMessageType.READ_RESOURCE.value:
                return await self._handle_read_resource(request_id, params)
            elif method == MCPMessageType.LIST_PROMPTS.value:
                return self._handle_list_prompts(request_id)
            elif method == MCPMessageType.GET_PROMPT.value:
                return await self._handle_get_prompt(request_id, params)
            else:
                return self._create_error_response(request_id, -32601, "Method not found")
                
        except Exception as e:
            logger.error(f"Error handling MCP request: {e}")
            return self._create_error_response(request.get("id"), -32603, str(e))
    
    def _handle_initialize(self, request_id: str, params: Dict) -> Dict:
        """Handle initialization request"""
        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "result": {
                "protocolVersion": "2024-11-05",
                "capabilities": {
                    "tools": {
                        "listChanged": True
                    },
                    "resources": {
                        "subscribe": True,
                        "listChanged": True
                    },
                    "prompts": {
                        "listChanged": True
                    }
                },
                "serverInfo": {
                    "name": "multimodal-mcp-server",
                    "version": "1.0.0",
                    "description": "Multimodal AI assistance for development workflows"
                }
            }
        }
    
    def _handle_list_tools(self, request_id: str) -> Dict:
        """Handle list tools request"""
        tools_list = []
        for tool in self.tools.values():
            tools_list.append({
                "name": tool.name,
                "description": tool.description,
                "inputSchema": tool.input_schema
            })
        
        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "result": {
                "tools": tools_list
            }
        }
    
    async def _handle_call_tool(self, request_id: str, params: Dict) -> Dict:
        """Handle tool call request"""
        tool_name = params.get("name")
        arguments = params.get("arguments", {})
        
        if tool_name not in self.tools:
            return self._create_error_response(request_id, -32602, f"Tool {tool_name} not found")
        
        try:
            # Execute tool based on name
            if tool_name == "analyze_codebase":
                result = await self._execute_analyze_codebase(arguments)
            elif tool_name == "search_code":
                result = await self._execute_search_code(arguments)
            elif tool_name == "generate_architecture_diagram":
                result = await self._execute_generate_diagram(arguments)
            elif tool_name == "analyze_image":
                result = await self._execute_analyze_image(arguments)
            elif tool_name == "transcribe_video":
                result = await self._execute_transcribe_video(arguments)
            elif tool_name == "generate_documentation":
                result = await self._execute_generate_documentation(arguments)
            else:
                return self._create_error_response(request_id, -32602, f"Tool {tool_name} not implemented")
            
            return {
                "jsonrpc": "2.0",
                "id": request_id,
                "result": {
                    "content": [
                        {
                            "type": "text",
                            "text": result
                        }
                    ]
                }
            }
            
        except Exception as e:
            logger.error(f"Error executing tool {tool_name}: {e}")
            return self._create_error_response(request_id, -32603, str(e))
    
    async def _execute_analyze_codebase(self, args: Dict) -> str:
        """Execute codebase analysis tool"""
        query = args.get("query")
        include_diagrams = args.get("include_diagrams", True)
        analysis_depth = args.get("analysis_depth", "standard")
        
        # Perform multimodal analysis
        analysis_result = await self.retrieval_client.search(
            query=query,
            modalities=["text"],
            limit=20
        )
        
        # Generate analysis report
        report_prompt = f"""
        Perform {analysis_depth} analysis of the codebase based on the following search results:
        
        Query: {query}
        
        Search Results:
        {analysis_result.get('context_bundle', {}).get('unified_context', '')}
        
        Provide analysis covering:
        1. Code quality and structure
        2. Security considerations
        3. Performance implications
        4. Architecture patterns
        5. Improvement recommendations
        """
        
        analysis_report = await self.multimodal_client.llm_client.generate_text(
            prompt=report_prompt,
            max_tokens=2000
        )
        
        if include_diagrams:
            diagram_result = await self._execute_generate_diagram({
                "component_focus": "all",
                "format": "mermaid"
            })
            analysis_report += f"\n\n## Architecture Diagram\n\n```mermaid\n{diagram_result}\n```"
        
        return analysis_report
    
    async def _execute_search_code(self, args: Dict) -> str:
        """Execute code search tool"""
        query = args.get("query")
        file_types = args.get("file_types", ["py", "js", "ts", "go", "java"])
        include_docs = args.get("include_docs", True)
        limit = args.get("limit", 10)
        
        # Perform search
        search_result = await self.retrieval_client.search(
            query=query,
            modalities=["text"] + (["documentation"] if include_docs else []),
            limit=limit,
            filters={"file_types": file_types}
        )
        
        # Format results
        results_text = f"Search Results for: {query}\n\n"
        
        for i, result in enumerate(search_result.get("results", []), 1):
            results_text += f"## Result {i}\n"
            results_text += f"**File**: {result.get('document_name', 'Unknown')}\n"
            results_text += f"**Score**: {result.get('score', 0):.3f}\n"
            results_text += f"**Content**:\n```\n{result.get('content', '')[:500]}...\n```\n\n"
        
        return results_text
    
    def _create_error_response(self, request_id: str, code: int, message: str) -> Dict:
        """Create error response"""
        return {
            "jsonrpc": "2.0",
            "id": request_id,
            "error": {
                "code": code,
                "message": message
            }
        }
```

### **3. Protocol Bridge Service**
Unified service managing both LSP and MCP protocols.

```python
# services/protocol-bridge/app/main.py
import asyncio
import logging
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

from .lsp_server import MultimodalLSPServer, create_lsp_server
from .mcp_server import MCPServer
from .protocol_manager import ProtocolManager

logger = logging.getLogger(__name__)

app = FastAPI(title="Protocol Bridge Service", version="1.0.0")

# CORS for IDE extensions
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global protocol manager
protocol_manager = None

@app.on_event("startup")
async def startup_event():
    """Initialize protocol bridge on startup"""
    global protocol_manager
    
    # Initialize clients
    from .clients import MultimodalClient, RetrievalClient, CodeContextEngine
    
    multimodal_client = MultimodalClient("http://multimodal-worker:8001")
    retrieval_client = RetrievalClient("http://retrieval-proxy:8002")
    context_engine = CodeContextEngine(multimodal_client, retrieval_client, None)
    
    # Create protocol servers
    lsp_server = await create_lsp_server()
    mcp_server = MCPServer(multimodal_client, retrieval_client)
    
    # Create protocol manager
    protocol_manager = ProtocolManager(lsp_server, mcp_server)
    
    logger.info("Protocol Bridge Service initialized")

@app.websocket("/lsp")
async def lsp_websocket(websocket: WebSocket):
    """LSP WebSocket endpoint"""
    await websocket.accept()
    
    try:
        while True:
            # Receive LSP message
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # Handle LSP request
            response = await protocol_manager.handle_lsp_request(message)
            
            # Send response
            await websocket.send_text(json.dumps(response))
            
    except WebSocketDisconnect:
        logger.info("LSP client disconnected")
    except Exception as e:
        logger.error(f"LSP WebSocket error: {e}")
        await websocket.close(code=1011, reason=str(e))

@app.websocket("/mcp")
async def mcp_websocket(websocket: WebSocket):
    """MCP WebSocket endpoint"""
    await websocket.accept()
    
    try:
        while True:
            # Receive MCP message
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # Handle MCP request
            response = await protocol_manager.handle_mcp_request(message)
            
            # Send response
            await websocket.send_text(json.dumps(response))
            
    except WebSocketDisconnect:
        logger.info("MCP client disconnected")
    except Exception as e:
        logger.error(f"MCP WebSocket error: {e}")
        await websocket.close(code=1011, reason=str(e))

@app.get("/protocols/supported")
async def get_supported_protocols():
    """Get list of supported protocols"""
    return {
        "protocols": [
            {
                "name": "LSP",
                "version": "3.17.0",
                "description": "Language Server Protocol for IDE integration",
                "endpoint": "/lsp",
                "capabilities": [
                    "completion",
                    "hover",
                    "definition",
                    "references",
                    "diagnostics",
                    "multimodal_analysis"
                ]
            },
            {
                "name": "MCP",
                "version": "2024-11-05",
                "description": "Microsoft Copilot Protocol for AI assistance",
                "endpoint": "/mcp",
                "capabilities": [
                    "tools",
                    "resources",
                    "prompts"
                ]
            }
        ]
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "protocol-bridge",
        "protocols": ["LSP", "MCP"],
        "version": "1.0.0"
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8008)
```

## 🛠️ **Technical Implementation**

### **IDE Extension Examples**

#### **VS Code Extension**
```typescript
// vscode-extension/src/extension.ts
import * as vscode from 'vscode';
import { LanguageClient, LanguageClientOptions, ServerOptions, TransportKind } from 'vscode-languageclient/node';

let client: LanguageClient;

export function activate(context: vscode.ExtensionContext) {
    // Server options for LSP
    const serverOptions: ServerOptions = {
        run: {
            command: 'node',
            args: ['path/to/multimodal-lsp-server.js'],
            transport: TransportKind.stdio
        },
        debug: {
            command: 'node',
            args: ['path/to/multimodal-lsp-server.js', '--debug'],
            transport: TransportKind.stdio
        }
    };

    // Client options
    const clientOptions: LanguageClientOptions = {
        documentSelector: [
            { scheme: 'file', language: 'python' },
            { scheme: 'file', language: 'javascript' },
            { scheme: 'file', language: 'typescript' },
            { scheme: 'file', language: 'go' },
            { scheme: 'file', language: 'java' }
        ],
        synchronize: {
            fileEvents: vscode.workspace.createFileSystemWatcher('**/*')
        }
    };

    // Create language client
    client = new LanguageClient(
        'multimodalLSP',
        'Multimodal Language Server',
        serverOptions,
        clientOptions
    );

    // Start client
    client.start();

    // Register commands
    context.subscriptions.push(
        vscode.commands.registerCommand('multimodal.analyzeCodebase', async () => {
            const editor = vscode.window.activeTextEditor;
            if (editor) {
                await client.sendRequest('multimodal/analyzeCodebase', {
                    uri: editor.document.uri.toString(),
                    analysisType: 'comprehensive'
                });
            }
        })
    );

    // Register MCP client for Copilot integration
    const mcpClient = new MCPClient('ws://localhost:8008/mcp');
    mcpClient.connect();
}

export function deactivate(): Thenable<void> | undefined {
    if (client) {
        return client.stop();
    }
}
```

#### **IntelliJ Plugin**
```kotlin
// intellij-plugin/src/main/kotlin/MultimodalPlugin.kt
class MultimodalPlugin : DumbAware, ApplicationComponent {
    
    private lateinit var lspClient: LanguageClient
    private lateinit var mcpClient: MCPClient
    
    override fun initComponent() {
        // Initialize LSP client
        lspClient = LanguageClient.builder()
            .withServerUrl("ws://localhost:8008/lsp")
            .build()
        
        // Initialize MCP client
        mcpClient = MCPClient("ws://localhost:8008/mcp")
        
        // Register completion contributor
        CompletionContributor.registerCompletionContributor(
            MultimodalCompletionContributor(lspClient),
            Disposer.newDisposable()
        )
        
        // Register inspection
        InspectionManager.getInstance().addInspection(
            MultimodalInspection(lspClient)
        )
    }
}
```

## 🧪 **Testing Strategy**

### **LSP Testing**
```python
# services/protocol-bridge/tests/test_lsp_server.py
import pytest
import asyncio
from unittest.mock import AsyncMock, Mock
from app.lsp_server import MultimodalLSPServer

@pytest.mark.asyncio
async def test_lsp_completion():
    """Test LSP completion functionality"""
    
    # Mock dependencies
    multimodal_client = AsyncMock()
    retrieval_client = AsyncMock()
    context_engine = AsyncMock()
    
    # Create LSP server
    server = MultimodalLSPServer(multimodal_client, retrieval_client, context_engine)
    
    # Mock context generation
    context_engine.generate_context.return_value = {
        "file_context": {"content": "def hello_world():\n    print("},
        "semantic_context": {"similar_code": "def hello_world():\n    return 'Hello World'"},
        "documentation": {"relevant_docs": "Function that prints hello world"}
    }
    
    # Mock completion generation
    multimodal_client.llm_client.generate_text.return_value = "hello_world, print, return"
    
    # Test completion
    params = {
        "textDocument": {"uri": "file://test.py"},
        "position": {"line": 1, "character": 4}
    }
    
    result = await server._provide_completion(params)
    
    assert isinstance(result, CompletionList)
    assert len(result.items) > 0
```

### **MCP Testing**
```python
# services/protocol-bridge/tests/test_mcp_server.py
import pytest
import asyncio
from unittest.mock import AsyncMock, Mock
from app.mcp_server import MCPServer

@pytest.mark.asyncio
async def test_mcp_tool_call():
    """Test MCP tool call functionality"""
    
    # Mock dependencies
    multimodal_client = AsyncMock()
    retrieval_client = AsyncMock()
    
    # Create MCP server
    server = MCPServer(multimodal_client, retrieval_client)
    
    # Mock tool execution
    retrieval_client.search.return_value = {
        "results": [{"content": "test content", "score": 0.9}],
        "context_bundle": {"unified_context": "test context"}
    }
    
    multimodal_client.llm_client.generate_text.return_value = "Analysis result"
    
    # Test tool call
    request = {
        "jsonrpc": "2.0",
        "id": "1",
        "method": "tools/call",
        "params": {
            "name": "analyze_codebase",
            "arguments": {
                "query": "test query",
                "analysis_depth": "standard"
            }
        }
    }
    
    response = await server.handle_request(request)
    
    assert response["jsonrpc"] == "2.0"
    assert response["id"] == "1"
    assert "result" in response
    assert "content" in response["result"]
```

## 📊 **Success Metrics**

### **Technical Metrics**
- **Protocol Compatibility**: 100% LSP 3.17.0 and MCP 2024-11-05 compliance
- **IDE Support**: 5+ IDE integrations (VS Code, IntelliJ, Vim, Emacs, Cursor)
- **Response Time**: <200ms for LSP requests, <500ms for MCP tool calls
- **Connection Stability**: 99.9% WebSocket connection uptime
- **Error Rate**: <1% protocol communication errors

### **User Experience Metrics**
- **Setup Time**: <5 minutes for IDE extension installation
- **Feature Adoption**: 80%+ of users actively using protocol features
- **User Satisfaction**: 4.5/5 rating for protocol integration quality
- **Cross-IDE Consistency**: 95%+ feature parity across supported IDEs

### **Integration Quality Metrics**
- **Tool Coverage**: 100% of multimodal tools accessible via MCP
- **Context Accuracy**: 90%+ relevant context in LSP completions
- **Protocol Reliability**: 99.9% uptime for protocol services
- **Performance**: <100ms latency for real-time protocol communication

## 🚀 **Deployment & Configuration**

### **Environment Variables**
```bash
# Protocol Bridge Service
PROTOCOL_BRIDGE_PORT=8008
LSP_ENDPOINT=/lsp
MCP_ENDPOINT=/mcp
PROTOCOL_TIMEOUT=30000
MAX_CONCURRENT_CONNECTIONS=100

# LSP Configuration
LSP_LOG_LEVEL=info
LSP_CACHE_SIZE=1000
LSP_CACHE_TTL=3600

# MCP Configuration
MCP_TOOL_TIMEOUT=60
MCP_RESOURCE_CACHE_SIZE=500
MCP_PROMPT_CACHE_SIZE=200

# Client Integration
MULTIMODAL_API_URL=http://multimodal-worker:8001
RETRIEVAL_API_URL=http://retrieval-proxy:8002
CONTEXT_ENGINE_URL=http://ide-bridge:8005
```

### **Docker Compose Integration**
```yaml
# Add new protocol-bridge service
services:
  protocol-bridge:
    build: ./services/protocol-bridge
    ports:
      - "8008:8008"
    environment:
      - PROTOCOL_BRIDGE_PORT=8008
      - MULTIMODAL_API_URL=http://multimodal-worker:8001
      - RETRIEVAL_API_URL=http://retrieval-proxy:8002
      - CONTEXT_ENGINE_URL=http://ide-bridge:8005
    depends_on:
      - multimodal-worker
      - retrieval-proxy
      - ide-bridge
    volumes:
      - ./services/protocol-bridge:/app
    networks:
      - multimodal-net
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8008/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## 📚 **Documentation Requirements**

### **User Documentation**
- [ ] **IDE Integration Guide**: Step-by-step setup for each supported IDE
- [ ] **Protocol Configuration**: Configuring LSP and MCP connections
- [ ] **Feature Reference**: Complete list of available protocol features
- [ ] **Troubleshooting Guide**: Common issues and solutions

### **Developer Documentation**
- [ ] **Protocol Specifications**: Detailed LSP and MCP implementation
- [ ] **Extension Development**: Creating IDE extensions with protocol support
- [ ] **API Reference**: Complete protocol API documentation
- [ ] **Integration Examples**: Real-world usage examples

### **Architecture Documentation**
- [ ] **Protocol Architecture**: Detailed component diagrams
- [ ] **Communication Patterns**: LSP and MCP message flows
- [ ] **Security Model**: Protocol authentication and authorization
- [ ] **Performance Guidelines**: Optimization recommendations

## ✅ **Acceptance Criteria**

### **Functional Requirements**
- [ ] Full LSP 3.17.0 protocol implementation with multimodal capabilities
- [ ] Complete MCP 2024-11-05 protocol implementation
- [ ] IDE extensions for VS Code, IntelliJ, Vim, Emacs, Cursor
- [ ] WebSocket-based protocol communication
- [ ] Tool registry with 10+ multimodal tools accessible via MCP
- [ ] Resource management for codebase information access

### **Performance Requirements**
- [ ] LSP requests complete within 200ms
- [ ] MCP tool calls complete within 500ms
- [ ] Support 100+ concurrent protocol connections
- [ ] 99.9% protocol communication reliability
- [ ] <100ms latency for real-time protocol features

### **Integration Requirements**
- [ ] Seamless integration with IDE Integration Foundation (P4.1)
- [ ] Full compatibility with multimodal stack services
- [ ] Cross-platform IDE support
- [ ] Health checks and monitoring integration
- [ ] Docker containerization with proper networking

---

**Estimated Effort**: 2 weeks  
**Risk Level**: Medium (protocol compliance, multiple IDE integrations)  
**Business Impact**: High (enables universal IDE integration)
